---
title:Prioritisation before Scaling
---

To prioritize it is hard. Most people are quite bad at it and want to avoid it. Saying no to something feels bad. The problem is that people feel that in order to choose to not do something that thing should not be important. The result is a long list of important stuff all with highest priority. But choosing between an important and an unimportant thing is not real prioritization. Real prioritization is the art of choosing between many important things. And prioritization is not about saying no it is saying "not now". Another thing that causes problems is our tendencies to simpify things by prioritizing too big things. Say we have two initiatives *A* and *B*. *A* has top priority and *B* has a lower priority but that does not mean that all things in *A* should have higher priority than all things in initiative *B*.

The ability to prioritize is key to success. If you want something to happen and do not prioritize the things that lead to the desired outcome it wil most likely never happen. With success prioritzation gets harder and even more important because success means there are more opportunities around to distract you from what you really need to do to continue to be successfull.

In software this is extremly apparent. I will use a classic example *the 2:nd system syndrome* to explain it here. 

####The 2:nd system syndrome

It all started with a simple idea. Wouldn´t it be great if XXX could be solved without all the hazzle of doing YYY and ZZZ. Or something along those lines.
The idea is realized by person or a team of persons that set out to solve the problem at hand. The product they create is launched and gets wide adoption.
But all users do not work in the same context as the solution was created for and for the ones that do work in the right context realize that with problem XXX
out of the way suddenly new problems pop up. Sometimes as a direct effect of the design choises in the product and sometimes it is just things that was hidden 
behind XXX. All users context are different and they all pour suggestions for how the product could be better. It could be solving design problems, Improve performance,simplify usage, new features for current users and new features to get new users. The list gets very long very fast so there is no way the original crew can do it all. The desission to increase delivery capacity is taken. In comes a lot of people that does not have the history of what lay 
behind the success of the first version, more things get worked on in parallel, things that was intentionally left out of version one sudddnly makes it into 
the product etc etc. Version two takes way longer to deliver than expected and when it arrives it is bloated with functionality that creates more problems than has been solved. Original users start to complain about how things that were once easy fast and nimble suddenly is now hard, slow and sluggish. 

####Prioritize first then scale (if needed).

The root to the problem is that there seems to be a way in wich you don´t need to prioritize. Should we do a or b ? Hire another team and do both! It seems so easy in theory but the reality is way more complicated. Scaling is allways the last resort and should be used carefully and allways after prioritization is done. There is even more reasons to be relentless in the efforts to establish clear prioritization in a multi team setup than in the small scale delivery where priorities is relatively simple to establish as the cost of not being aligned is growing rapidly with scale. Another built in problem is that the development capacity of 2 teams are never the sum of the individual teams capacity. Anyone that is interested in understanding the mechanics of this should read Fred Brooks classic book [*The mythical man month*](https://en.wikipedia.org/wiki/The_Mythical_Man-Month) from 1975 in wich he thouroghly goes through many of the inherent problems in large scale software development.


        